{// generated from grammar.peg
package dslparser

import (
	"bytes"
	"fmt"
	"io"
	"errors"
	"io/ioutil"
	"os"
	"strings"
	"unicode"
	"unicode/utf8"

	"golang.org/x/text/unicode/norm"
)

var transcriptionMap = map[rune]string{
    'Ћ': "Ө",
    'Ђ': "i:",
    '\'': "ˈ",
    'э': "ɪ",
    'Ѓ': "ɑ:",
    '†': "ə",
    '‡': "æ",
    '…': "ʌ",
    'Њ': "ŋ",
    'ю': "ɜ:",
    '‚': "ɔ",
    'ѓ': "u:",
    '¶': "ʊ",
    '€': "ɔ",
    '‹': "dʒ",
    'Џ': "ʃ",
    ' ': "tʃ", // ʧ
    '‰': "ð",
    'Љ': "ʒ",
}
}
All ⟵ b:Body EOF {
    return b.(string), nil
}

Body ⟵ ps:Part+ {
    var result strings.Builder
    for _, pitf := range ps.([]interface{}) {
        result.WriteString(pitf.(string))
    }
    return result.String(), nil
}

Part ⟵ EscapeSequence / Accent / Transcription / Image / OpenTag / CloseTag / Newline / Anything

EscapeSequence ⟵ '\\' ch:('[' / ']') {
    return string(ch.([]byte)), nil
}

Accent ⟵ "[']" ch:. "[/']" {
    buff := norm.NFD.Bytes(ch.([]byte))
    buff = norm.NFD.AppendString(buff, "\u0301")
    buff = norm.NFC.Bytes(buff)
    return fmt.Sprintf(`<v-accent>%s</v-accent>`, buff), nil
}

Transcription ⟵ "[t]" ps:( EscapeSequence / [^[] )+ "[/t]" {
    var result strings.Builder
    result.WriteString(`<v-trx>`)
    for _, pitf := range ps.([]interface{}) {
        switch p := pitf.(type) {
        case string:
            result.WriteString(p)
        case []byte:
            r, _ := utf8.DecodeRune(p)
            if r == utf8.RuneError {
                return nil, fmt.Errorf("decode rune from %v", p)
            }
            if rm, ok := transcriptionMap[r]; ok {
                result.WriteString(rm)
            } else {
                result.WriteRune(r)
            }
        default:
            return nil, fmt.Errorf("unknown transcription type %T of %v", p, p)
        }
    }
    result.WriteString(`</v-trx>`)
    return result.String(), nil
}

Image ⟵ "[s]" fnitf:( EscapeSequence / [^[] )+ "[/s]" {
    // TODO: extract function: []interface{} to string convertion
    var result strings.Builder
    for _, vitf := range fnitf.([]interface{}) {
        switch v := vitf.(type) {
        case string:
            result.WriteString(v)
        case []byte:
            result.Write(v)
        default:
            return nil, fmt.Errorf("unknown image tag content part type %T of %v", v, v)
        }
    }
    fn := result.String()
    dictID := c.globalStore["dictID"].(string)
    return fmt.Sprintf(`<img src="/images/%s/%s" alt="%s"/>`, dictID, fn, fn), nil
}

OpenTag ⟵ '[' tnitf:Tagname targ:Tagarg? ']' {
    tn := tnitf.(string)
    switch tn {
    case "c":
        if targ == nil {
            targ = "darkgreen"
        }
        return fmt.Sprintf(`<span style="color: %s">`, targ), nil
    case "m1":
        return `<p class="ml-0">`, nil
    case "m2":
        return `<p class="ml-2">`, nil
    case "m3":
        return `<p class="ml-4">`, nil
    case "b":
        return `<strong>`, nil
    case "sup":
        return `<sup>`, nil
    case "p":
        return ``, nil
    case "ex":
        return `<v-ex>`, nil
    case "lang":
        return ``, nil
    case "i":
        return `<i>`, nil
    case "com":
        return `<span style="color: darkgreen">`, nil
    case "trn":
        return ``, nil
    case "*":
        return ``, nil
    case "ref":
        return ``, nil
    default:
        return "unknowntag:"+tn, nil
    }
}

CloseTag ⟵ "[/" tnitf:Tagname ']' {
    tn := tnitf.(string)
    switch tn {
    case "c":
        return `</span>`, nil
    case "b":
        return `</strong>`, nil
    case "sup":
        return `</sup>`, nil
    case "p":
        return ``, nil
    case "ex":
        return `</v-ex>`, nil
    case "lang":
        return ``, nil
    case "i":
        return `</i>`, nil
    case "com":
        return `</span>`, nil
    case "trn":
        return ``, nil
    case "m":
        return ``, nil
    case "*":
        return ``, nil
    case "ref":
        return ``, nil
    default:
        return "unknowntag:"+tn, nil
    }
}

Tagname ⟵ n:("m1" / "m2" / "m3" / "m" / "b" / "com" / "c" / "'" / "sup" / "p" / "ex" / "lang" / "i" / "trn" / "*" / "ref") {
    return string(n.([]byte)), nil
}

Tagarg ⟵ ' ' v:[a-z0-9=]+ {
    var result strings.Builder
    for _, vitf := range v.([]interface{}) {
        result.Write(vitf.([]byte))
    }
    return result.String(), nil
}

Newline ⟵ "\n" {
    return `</p>`, nil
}

Anything ⟵ ch:. {
    return string(ch.([]byte)), nil
}

EOF ⟵ !.
